// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package v1

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

// CoreClient is the client API for Core service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CoreClient interface {
	AddLiveRoomDanmu(ctx context.Context, in *AddLiveRoomDanmuReq, opts ...grpc.CallOption) (*AddLiveRoomDanmuResp, error)
	DelLiveRoomDanmu(ctx context.Context, in *DelLiveRoomDanmuReq, opts ...grpc.CallOption) (*DelLiveRoomDanmuResp, error)
	UpdateLiveRoomDanmu(ctx context.Context, in *UpdateLiveRoomDanmuReq, opts ...grpc.CallOption) (*UpdateLiveRoomDanmuResp, error)
	EnableLiveRoomDanmu(ctx context.Context, in *EnableLiveRoomDanmuReq, opts ...grpc.CallOption) (*EnableLiveRoomDanmuResp, error)
	DisableLiveRoomDanmu(ctx context.Context, in *DisableLiveRoomDanmuReq, opts ...grpc.CallOption) (*DisableLiveRoomDanmuResp, error)
	AddRule(ctx context.Context, in *AddRuleReq, opts ...grpc.CallOption) (*AddRuleResp, error)
	DelRule(ctx context.Context, in *DelRuleReq, opts ...grpc.CallOption) (*DelRuleResp, error)
	UpdateRule(ctx context.Context, in *UpdateRuleReq, opts ...grpc.CallOption) (*UpdateRuleResp, error)
	EnableRule(ctx context.Context, in *EnableRuleReq, opts ...grpc.CallOption) (*EnableRuleResp, error)
	DisableRule(ctx context.Context, in *DisableRuleReq, opts ...grpc.CallOption) (*DisableRuleResp, error)
	PreCheckDelRule(ctx context.Context, in *PreCheckDelRuleReq, opts ...grpc.CallOption) (*PreCheckDelRuleResp, error)
	AddAction(ctx context.Context, in *AddActionReq, opts ...grpc.CallOption) (*AddActionResp, error)
	DelAction(ctx context.Context, in *DelActionReq, opts ...grpc.CallOption) (*DelActionResp, error)
	UpdateAction(ctx context.Context, in *UpdateActionReq, opts ...grpc.CallOption) (*UpdateActionResp, error)
	EnableAction(ctx context.Context, in *EnableActionReq, opts ...grpc.CallOption) (*EnableActionResp, error)
	DisableAction(ctx context.Context, in *DisableActionReq, opts ...grpc.CallOption) (*DisableActionResp, error)
	PreCheckDelAction(ctx context.Context, in *PreCheckDelActionReq, opts ...grpc.CallOption) (*PreCheckDelActionResp, error)
}

type coreClient struct {
	cc grpc.ClientConnInterface
}

func NewCoreClient(cc grpc.ClientConnInterface) CoreClient {
	return &coreClient{cc}
}

func (c *coreClient) AddLiveRoomDanmu(ctx context.Context, in *AddLiveRoomDanmuReq, opts ...grpc.CallOption) (*AddLiveRoomDanmuResp, error) {
	out := new(AddLiveRoomDanmuResp)
	err := c.cc.Invoke(ctx, "/v1.Core/AddLiveRoomDanmu", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) DelLiveRoomDanmu(ctx context.Context, in *DelLiveRoomDanmuReq, opts ...grpc.CallOption) (*DelLiveRoomDanmuResp, error) {
	out := new(DelLiveRoomDanmuResp)
	err := c.cc.Invoke(ctx, "/v1.Core/DelLiveRoomDanmu", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) UpdateLiveRoomDanmu(ctx context.Context, in *UpdateLiveRoomDanmuReq, opts ...grpc.CallOption) (*UpdateLiveRoomDanmuResp, error) {
	out := new(UpdateLiveRoomDanmuResp)
	err := c.cc.Invoke(ctx, "/v1.Core/UpdateLiveRoomDanmu", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) EnableLiveRoomDanmu(ctx context.Context, in *EnableLiveRoomDanmuReq, opts ...grpc.CallOption) (*EnableLiveRoomDanmuResp, error) {
	out := new(EnableLiveRoomDanmuResp)
	err := c.cc.Invoke(ctx, "/v1.Core/EnableLiveRoomDanmu", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) DisableLiveRoomDanmu(ctx context.Context, in *DisableLiveRoomDanmuReq, opts ...grpc.CallOption) (*DisableLiveRoomDanmuResp, error) {
	out := new(DisableLiveRoomDanmuResp)
	err := c.cc.Invoke(ctx, "/v1.Core/DisableLiveRoomDanmu", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) AddRule(ctx context.Context, in *AddRuleReq, opts ...grpc.CallOption) (*AddRuleResp, error) {
	out := new(AddRuleResp)
	err := c.cc.Invoke(ctx, "/v1.Core/AddRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) DelRule(ctx context.Context, in *DelRuleReq, opts ...grpc.CallOption) (*DelRuleResp, error) {
	out := new(DelRuleResp)
	err := c.cc.Invoke(ctx, "/v1.Core/DelRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) UpdateRule(ctx context.Context, in *UpdateRuleReq, opts ...grpc.CallOption) (*UpdateRuleResp, error) {
	out := new(UpdateRuleResp)
	err := c.cc.Invoke(ctx, "/v1.Core/UpdateRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) EnableRule(ctx context.Context, in *EnableRuleReq, opts ...grpc.CallOption) (*EnableRuleResp, error) {
	out := new(EnableRuleResp)
	err := c.cc.Invoke(ctx, "/v1.Core/EnableRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) DisableRule(ctx context.Context, in *DisableRuleReq, opts ...grpc.CallOption) (*DisableRuleResp, error) {
	out := new(DisableRuleResp)
	err := c.cc.Invoke(ctx, "/v1.Core/DisableRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) PreCheckDelRule(ctx context.Context, in *PreCheckDelRuleReq, opts ...grpc.CallOption) (*PreCheckDelRuleResp, error) {
	out := new(PreCheckDelRuleResp)
	err := c.cc.Invoke(ctx, "/v1.Core/PreCheckDelRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) AddAction(ctx context.Context, in *AddActionReq, opts ...grpc.CallOption) (*AddActionResp, error) {
	out := new(AddActionResp)
	err := c.cc.Invoke(ctx, "/v1.Core/AddAction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) DelAction(ctx context.Context, in *DelActionReq, opts ...grpc.CallOption) (*DelActionResp, error) {
	out := new(DelActionResp)
	err := c.cc.Invoke(ctx, "/v1.Core/DelAction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) UpdateAction(ctx context.Context, in *UpdateActionReq, opts ...grpc.CallOption) (*UpdateActionResp, error) {
	out := new(UpdateActionResp)
	err := c.cc.Invoke(ctx, "/v1.Core/UpdateAction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) EnableAction(ctx context.Context, in *EnableActionReq, opts ...grpc.CallOption) (*EnableActionResp, error) {
	out := new(EnableActionResp)
	err := c.cc.Invoke(ctx, "/v1.Core/EnableAction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) DisableAction(ctx context.Context, in *DisableActionReq, opts ...grpc.CallOption) (*DisableActionResp, error) {
	out := new(DisableActionResp)
	err := c.cc.Invoke(ctx, "/v1.Core/DisableAction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *coreClient) PreCheckDelAction(ctx context.Context, in *PreCheckDelActionReq, opts ...grpc.CallOption) (*PreCheckDelActionResp, error) {
	out := new(PreCheckDelActionResp)
	err := c.cc.Invoke(ctx, "/v1.Core/PreCheckDelAction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CoreServer is the server API for Core service.
// All implementations must embed UnimplementedCoreServer
// for forward compatibility
type CoreServer interface {
	AddLiveRoomDanmu(context.Context, *AddLiveRoomDanmuReq) (*AddLiveRoomDanmuResp, error)
	DelLiveRoomDanmu(context.Context, *DelLiveRoomDanmuReq) (*DelLiveRoomDanmuResp, error)
	UpdateLiveRoomDanmu(context.Context, *UpdateLiveRoomDanmuReq) (*UpdateLiveRoomDanmuResp, error)
	EnableLiveRoomDanmu(context.Context, *EnableLiveRoomDanmuReq) (*EnableLiveRoomDanmuResp, error)
	DisableLiveRoomDanmu(context.Context, *DisableLiveRoomDanmuReq) (*DisableLiveRoomDanmuResp, error)
	AddRule(context.Context, *AddRuleReq) (*AddRuleResp, error)
	DelRule(context.Context, *DelRuleReq) (*DelRuleResp, error)
	UpdateRule(context.Context, *UpdateRuleReq) (*UpdateRuleResp, error)
	EnableRule(context.Context, *EnableRuleReq) (*EnableRuleResp, error)
	DisableRule(context.Context, *DisableRuleReq) (*DisableRuleResp, error)
	PreCheckDelRule(context.Context, *PreCheckDelRuleReq) (*PreCheckDelRuleResp, error)
	AddAction(context.Context, *AddActionReq) (*AddActionResp, error)
	DelAction(context.Context, *DelActionReq) (*DelActionResp, error)
	UpdateAction(context.Context, *UpdateActionReq) (*UpdateActionResp, error)
	EnableAction(context.Context, *EnableActionReq) (*EnableActionResp, error)
	DisableAction(context.Context, *DisableActionReq) (*DisableActionResp, error)
	PreCheckDelAction(context.Context, *PreCheckDelActionReq) (*PreCheckDelActionResp, error)
	mustEmbedUnimplementedCoreServer()
}

// UnimplementedCoreServer must be embedded to have forward compatible implementations.
type UnimplementedCoreServer struct {
}

func (UnimplementedCoreServer) AddLiveRoomDanmu(context.Context, *AddLiveRoomDanmuReq) (*AddLiveRoomDanmuResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddLiveRoomDanmu not implemented")
}
func (UnimplementedCoreServer) DelLiveRoomDanmu(context.Context, *DelLiveRoomDanmuReq) (*DelLiveRoomDanmuResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DelLiveRoomDanmu not implemented")
}
func (UnimplementedCoreServer) UpdateLiveRoomDanmu(context.Context, *UpdateLiveRoomDanmuReq) (*UpdateLiveRoomDanmuResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateLiveRoomDanmu not implemented")
}
func (UnimplementedCoreServer) EnableLiveRoomDanmu(context.Context, *EnableLiveRoomDanmuReq) (*EnableLiveRoomDanmuResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnableLiveRoomDanmu not implemented")
}
func (UnimplementedCoreServer) DisableLiveRoomDanmu(context.Context, *DisableLiveRoomDanmuReq) (*DisableLiveRoomDanmuResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisableLiveRoomDanmu not implemented")
}
func (UnimplementedCoreServer) AddRule(context.Context, *AddRuleReq) (*AddRuleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddRule not implemented")
}
func (UnimplementedCoreServer) DelRule(context.Context, *DelRuleReq) (*DelRuleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DelRule not implemented")
}
func (UnimplementedCoreServer) UpdateRule(context.Context, *UpdateRuleReq) (*UpdateRuleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRule not implemented")
}
func (UnimplementedCoreServer) EnableRule(context.Context, *EnableRuleReq) (*EnableRuleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnableRule not implemented")
}
func (UnimplementedCoreServer) DisableRule(context.Context, *DisableRuleReq) (*DisableRuleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisableRule not implemented")
}
func (UnimplementedCoreServer) PreCheckDelRule(context.Context, *PreCheckDelRuleReq) (*PreCheckDelRuleResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PreCheckDelRule not implemented")
}
func (UnimplementedCoreServer) AddAction(context.Context, *AddActionReq) (*AddActionResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddAction not implemented")
}
func (UnimplementedCoreServer) DelAction(context.Context, *DelActionReq) (*DelActionResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DelAction not implemented")
}
func (UnimplementedCoreServer) UpdateAction(context.Context, *UpdateActionReq) (*UpdateActionResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAction not implemented")
}
func (UnimplementedCoreServer) EnableAction(context.Context, *EnableActionReq) (*EnableActionResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnableAction not implemented")
}
func (UnimplementedCoreServer) DisableAction(context.Context, *DisableActionReq) (*DisableActionResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisableAction not implemented")
}
func (UnimplementedCoreServer) PreCheckDelAction(context.Context, *PreCheckDelActionReq) (*PreCheckDelActionResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PreCheckDelAction not implemented")
}
func (UnimplementedCoreServer) mustEmbedUnimplementedCoreServer() {}

// UnsafeCoreServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CoreServer will
// result in compilation errors.
type UnsafeCoreServer interface {
	mustEmbedUnimplementedCoreServer()
}

func RegisterCoreServer(s grpc.ServiceRegistrar, srv CoreServer) {
	s.RegisterService(&Core_ServiceDesc, srv)
}

func _Core_AddLiveRoomDanmu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddLiveRoomDanmuReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).AddLiveRoomDanmu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.Core/AddLiveRoomDanmu",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).AddLiveRoomDanmu(ctx, req.(*AddLiveRoomDanmuReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_DelLiveRoomDanmu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DelLiveRoomDanmuReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).DelLiveRoomDanmu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.Core/DelLiveRoomDanmu",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).DelLiveRoomDanmu(ctx, req.(*DelLiveRoomDanmuReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_UpdateLiveRoomDanmu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateLiveRoomDanmuReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).UpdateLiveRoomDanmu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.Core/UpdateLiveRoomDanmu",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).UpdateLiveRoomDanmu(ctx, req.(*UpdateLiveRoomDanmuReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_EnableLiveRoomDanmu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableLiveRoomDanmuReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).EnableLiveRoomDanmu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.Core/EnableLiveRoomDanmu",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).EnableLiveRoomDanmu(ctx, req.(*EnableLiveRoomDanmuReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_DisableLiveRoomDanmu_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisableLiveRoomDanmuReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).DisableLiveRoomDanmu(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.Core/DisableLiveRoomDanmu",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).DisableLiveRoomDanmu(ctx, req.(*DisableLiveRoomDanmuReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_AddRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddRuleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).AddRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.Core/AddRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).AddRule(ctx, req.(*AddRuleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_DelRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DelRuleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).DelRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.Core/DelRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).DelRule(ctx, req.(*DelRuleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_UpdateRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRuleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).UpdateRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.Core/UpdateRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).UpdateRule(ctx, req.(*UpdateRuleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_EnableRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableRuleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).EnableRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.Core/EnableRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).EnableRule(ctx, req.(*EnableRuleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_DisableRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisableRuleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).DisableRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.Core/DisableRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).DisableRule(ctx, req.(*DisableRuleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_PreCheckDelRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PreCheckDelRuleReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).PreCheckDelRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.Core/PreCheckDelRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).PreCheckDelRule(ctx, req.(*PreCheckDelRuleReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_AddAction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddActionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).AddAction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.Core/AddAction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).AddAction(ctx, req.(*AddActionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_DelAction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DelActionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).DelAction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.Core/DelAction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).DelAction(ctx, req.(*DelActionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_UpdateAction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateActionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).UpdateAction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.Core/UpdateAction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).UpdateAction(ctx, req.(*UpdateActionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_EnableAction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableActionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).EnableAction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.Core/EnableAction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).EnableAction(ctx, req.(*EnableActionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_DisableAction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisableActionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).DisableAction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.Core/DisableAction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).DisableAction(ctx, req.(*DisableActionReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _Core_PreCheckDelAction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PreCheckDelActionReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CoreServer).PreCheckDelAction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.Core/PreCheckDelAction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CoreServer).PreCheckDelAction(ctx, req.(*PreCheckDelActionReq))
	}
	return interceptor(ctx, in, info, handler)
}

// Core_ServiceDesc is the grpc.ServiceDesc for Core service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Core_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "v1.Core",
	HandlerType: (*CoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddLiveRoomDanmu",
			Handler:    _Core_AddLiveRoomDanmu_Handler,
		},
		{
			MethodName: "DelLiveRoomDanmu",
			Handler:    _Core_DelLiveRoomDanmu_Handler,
		},
		{
			MethodName: "UpdateLiveRoomDanmu",
			Handler:    _Core_UpdateLiveRoomDanmu_Handler,
		},
		{
			MethodName: "EnableLiveRoomDanmu",
			Handler:    _Core_EnableLiveRoomDanmu_Handler,
		},
		{
			MethodName: "DisableLiveRoomDanmu",
			Handler:    _Core_DisableLiveRoomDanmu_Handler,
		},
		{
			MethodName: "AddRule",
			Handler:    _Core_AddRule_Handler,
		},
		{
			MethodName: "DelRule",
			Handler:    _Core_DelRule_Handler,
		},
		{
			MethodName: "UpdateRule",
			Handler:    _Core_UpdateRule_Handler,
		},
		{
			MethodName: "EnableRule",
			Handler:    _Core_EnableRule_Handler,
		},
		{
			MethodName: "DisableRule",
			Handler:    _Core_DisableRule_Handler,
		},
		{
			MethodName: "PreCheckDelRule",
			Handler:    _Core_PreCheckDelRule_Handler,
		},
		{
			MethodName: "AddAction",
			Handler:    _Core_AddAction_Handler,
		},
		{
			MethodName: "DelAction",
			Handler:    _Core_DelAction_Handler,
		},
		{
			MethodName: "UpdateAction",
			Handler:    _Core_UpdateAction_Handler,
		},
		{
			MethodName: "EnableAction",
			Handler:    _Core_EnableAction_Handler,
		},
		{
			MethodName: "DisableAction",
			Handler:    _Core_DisableAction_Handler,
		},
		{
			MethodName: "PreCheckDelAction",
			Handler:    _Core_PreCheckDelAction_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/v1/core.proto",
}
